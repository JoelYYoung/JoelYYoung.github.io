<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Static Program Analysis on Joel Yang</title><link>https://joelyyoung.github.io/tags/static-program-analysis/</link><description>Recent content in Static Program Analysis on Joel Yang</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 21 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://joelyyoung.github.io/tags/static-program-analysis/index.xml" rel="self" type="application/rss+xml"/><item><title>Static Program Analysis Reading Note: Chapter 6</title><link>https://joelyyoung.github.io/static-program-analysis-reading-note-chapter6/</link><pubDate>Wed, 15 Feb 2023 00:00:00 +0000</pubDate><guid>https://joelyyoung.github.io/static-program-analysis-reading-note-chapter6/</guid><description>&lt;h1 id="static-program-analysis-reading-note-chapter-6">Static Program Analysis Reading Note: Chapter 6&lt;/h1>
&lt;h2 id="why-need-widening">Why Need &lt;em>Widening&lt;/em>?&lt;/h2>
&lt;p>&lt;strong>Recap&lt;/strong>: In Chapter 5, we introduced &lt;em>Iterative Algorithm&lt;/em> and &lt;em>Worklist Algorithm&lt;/em> to calculate the $lfp$ of the given constraint (for &lt;em>May Analysis&lt;/em>). The correctness of the mentioned algorithm demands that the lattice has &lt;strong>limited height&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>Problem&lt;/strong>: What happens if the lattice has infinit height? E.g., in interval analysis, we use ${[l,u]|l,u \in N }$ as the lattice, which has infinit height.&lt;/p></description></item><item><title>Static Program Analysis Reading Note: Chapter 5</title><link>https://joelyyoung.github.io/static-program-analysis-reading-note-chapter5/</link><pubDate>Mon, 02 Jan 2023 00:00:00 +0000</pubDate><guid>https://joelyyoung.github.io/static-program-analysis-reading-note-chapter5/</guid><description>&lt;h1 id="static-program-analysis-reading-note-chapter-5">Static Program Analysis Reading Note: Chapter 5&lt;/h1>
&lt;h2 id="brief">Brief&lt;/h2>
&lt;p>&lt;em>&lt;strong>Recap&lt;/strong>&lt;/em> How do we build a constraint system for a given program (CFG)?&lt;/p>
&lt;p>We firstly define a &lt;em>states&lt;/em> variable $[v]$ for each CFG vertex $v$, and we then generate constraints between those &lt;em>states&lt;/em> variables, usually between neighboring vertexes, according to dataflow relations represented by the CFG and the programming language. Note that those constraints could be &lt;em>equations&lt;/em> or &lt;em>inequations&lt;/em>, and the latter could be transformed into &lt;em>equations&lt;/em>.&lt;/p></description></item><item><title>Static Program Analysis Reading Note: Chapter 4</title><link>https://joelyyoung.github.io/static-program-analysis-reading-note-chapter4/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://joelyyoung.github.io/static-program-analysis-reading-note-chapter4/</guid><description>&lt;h1 id="static-program-analysis-reading-note-chapter-4">Static Program Analysis Reading Note: Chapter 4&lt;/h1>
&lt;h2 id="basic-math-languages">Basic Math Languages&lt;/h2>
&lt;p>&lt;strong>Def &lt;em>partial order set (poset)&lt;/em>&lt;/strong>: A pair $(S,R)$. $S$ is a set; $R$ (also denoted as $\sqsubseteq$) is a &lt;em>binary relation&lt;/em> on $S$ that satisfies the following rules:&lt;/p>
&lt;ul>
&lt;li>reflexivity: $\forall x \in S, x \sqsubseteq x$.&lt;/li>
&lt;li>transitivity: $\forall x,y,z \in S, x \sqsubseteq y \wedge y \sqsubseteq z \rightarrow x \sqsubseteq z$.&lt;/li>
&lt;li>anti-symmetry: $ \forall x, y \in S, x \sqsubseteq y \wedge y \sqsubseteq x \rightarrow x=y $&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Note&lt;/strong>: If we use the terminology &lt;em>partial order relation&lt;/em>, we usually denote $R$ instead of $(S,R)$.&lt;/p></description></item><item><title>Static Program Analysis Reading Note: Introduction</title><link>https://joelyyoung.github.io/static-program-analysis-reading-note-introduction/</link><pubDate>Sat, 03 Dec 2022 00:00:00 +0000</pubDate><guid>https://joelyyoung.github.io/static-program-analysis-reading-note-introduction/</guid><description>&lt;h1 id="target-of-spa">Target of SPA&lt;/h1>
&lt;p>&lt;em>&lt;strong>Target 1&lt;/strong>&lt;/em>: To answer any none-trivial questions of a program at given &lt;em>program point&lt;/em>, e.g.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Whether&lt;/strong> the judgement that &lt;code>x &amp;gt; const&lt;/code> always true, i.e., invariant.&lt;/li>
&lt;li>&lt;strong>What&lt;/strong> is the possible range of a number x?&lt;/li>
&lt;/ul>
&lt;p>&lt;em>&lt;strong>Target 2&lt;/strong>&lt;/em>: To answer any questions of a program, e.g.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>How&lt;/strong> much memory could the program consume?&lt;/li>
&lt;li>&lt;strong>Whether&lt;/strong> the program terminates on all legal inputs?&lt;/li>
&lt;/ul>
&lt;p>They concerns both &amp;ldquo;yes-or-no&amp;rdquo; questions and more general questions. As to two typical problems, &lt;em>bug detecting&lt;/em> and &lt;em>program verification&lt;/em>, we can sovle them by reducing to a basic questions: &amp;ldquo;is each statement error free?&amp;rdquo;.&lt;/p></description></item><item><title>Static Program Analysis Thought: path conditions</title><link>https://joelyyoung.github.io/static-program-analysis-thought-path-conditions/</link><pubDate>Sat, 03 Dec 2022 00:00:00 +0000</pubDate><guid>https://joelyyoung.github.io/static-program-analysis-thought-path-conditions/</guid><description>&lt;h1 id="path-conditions">Path Conditions&lt;/h1>
&lt;h2 id="brief">Brief&lt;/h2>
&lt;p>In this artical, I give the formal statement of handling path conditions.&lt;/p></description></item></channel></rss>