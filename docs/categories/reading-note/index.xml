<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Reading Note on Joel Yang</title>
    <link>https://joelyyoung.github.io/categories/reading-note/</link>
    <description>Recent content in Reading Note on Joel Yang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 15 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://joelyyoung.github.io/categories/reading-note/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Static Program Analysis Reading Note: Chapter 6</title>
      <link>https://joelyyoung.github.io/static-program-analysis-reading-note-chapter6/</link>
      <pubDate>Wed, 15 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://joelyyoung.github.io/static-program-analysis-reading-note-chapter6/</guid>
      <description>Static Program Analysis Reading Note: Chapter 6 Why Need Widening? Recap: In Chapter 5, we introduced Iterative Algorithm and Worklist Algorithm to calculate the $lfp$ of the given constraint (for May Analysis). The correctness of the mentioned algorithm demands that the lattice has limited height.
Problem: What happens if the lattice has infinit height? E.g., in interval analysis, we use ${[l,u]|l,u \in N }$ as the lattice, which has infinit height.</description>
    </item>
    
    <item>
      <title>Static Program Analysis Reading Note: Chapter 5</title>
      <link>https://joelyyoung.github.io/static-program-analysis-reading-note-chapter5/</link>
      <pubDate>Mon, 02 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://joelyyoung.github.io/static-program-analysis-reading-note-chapter5/</guid>
      <description>Static Program Analysis Reading Note: Chapter 5 Brief Recap How do we build a constraint system for a given program (CFG)?
We firstly define a states variable $[v]$ for each CFG vertex $v$, and we then generate constraints between those states variables, usually between neighboring vertexes, according to dataflow relations represented by the CFG and the programming language. Note that those constraints could be equations or inequations, and the latter could be transformed into equations.</description>
    </item>
    
    <item>
      <title>Static Program Analysis Reading Note: Chapter 4</title>
      <link>https://joelyyoung.github.io/static-program-analysis-reading-note-chapter4/</link>
      <pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://joelyyoung.github.io/static-program-analysis-reading-note-chapter4/</guid>
      <description>Static Program Analysis Reading Note: Chapter 4 Basic Math Languages Def partial order set (poset): A pair $(S,R)$. $S$ is a set; $R$ (also denoted as $\sqsubseteq$) is a binary relation on $S$ that satisfies the following rules:
reflexivity: $\forall x \in S, x \sqsubseteq x$. transitivity: $\forall x,y,z \in S, x \sqsubseteq y \wedge y \sqsubseteq z \rightarrow x \sqsubseteq z$. anti-symmetry: $ \forall x, y \in S, x \sqsubseteq y \wedge y \sqsubseteq x \rightarrow x=y $ Note: If we use the terminology partial order relation, we usually denote $R$ instead of $(S,R)$.</description>
    </item>
    
    <item>
      <title>Static Program Analysis Reading Note: Introduction</title>
      <link>https://joelyyoung.github.io/static-program-analysis-reading-note-introduction/</link>
      <pubDate>Sat, 03 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://joelyyoung.github.io/static-program-analysis-reading-note-introduction/</guid>
      <description>Target of SPA Target 1: To answer any none-trivial questions of a program at given program point, e.g.
Whether the judgement that x &amp;gt; const always true, i.e., invariant. What is the possible range of a number x? Target 2: To answer any questions of a program, e.g.
How much memory could the program consume? Whether the program terminates on all legal inputs? They concerns both &amp;ldquo;yes-or-no&amp;rdquo; questions and more general questions.</description>
    </item>
    
  </channel>
</rss>
